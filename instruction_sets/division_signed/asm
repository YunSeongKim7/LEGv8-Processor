// Load initial values
LDUR X9,  [X22, #0]   // dividend
LDUR X10, [X22, #8]   // divisor
ADD  X11, XZR, XZR    // quotient
ADD  X12, X9,  XZR    // remainder

CMPI X9, #0           // is dividend < 0?
B.GE #3
ADDI X13, XZR, #1     // dividendNegative
SUB  X12, XZR, X12    // Fix remainder sign
SUB  X9,  XZR, X9     // two's compliment
CMPI X10, #0          // is divisor < 0?
B.GE #3
ADDI X14, XZR, #1     // divisorNegative
SUB  X10, XZR, X10    // two's compliment
CMPI X12, #0          // begin while loop - condition: remainder > 0
B.LT #4
SUB  X12, X12, X10    // decrease remainder by divisor
ADDI X11, X11, #1     // increase quotient by 1
B    #-4
ADD  X12, X12, X10    // While loop always runs an extra time,
SUBI X11, X11, #1     // so undo one iteration 
CBZ  X13, #3          // Skip following sub instr if both
CBZ  X14, #2          // dividendNegative and divisorNegative are == 0
SUB  X12, XZR, X12    // invert remainder
CMP  X13, X14         // Skip following sub instr if 
B.EQ #2               // dividendNegative == divisorNegative
SUB  X11, XZR, X11
STUR X11, [X22, #16]  // Store quotient and remainder
STUR X12, [X22, #24]